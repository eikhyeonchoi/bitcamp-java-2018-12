///////////////////////////////////////////////////////////////////////////////////////////////////
//
// 1단계 : 클라이언트와 통신하는 기능으로 변경
//
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// 2단계 : 규칙1 에따라 클라이언트 게시물 목록 보내기
//       teacher 프로젝트 java-project2-server 참고
//
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// 3단계 : 규칙2
//       teacher 프로젝트 java-project2-server 참고
// 
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// 4단계 Command를 다루는 클래스에 대해 리팩토링수행
// ==> Command를 미리 구현한 AbstractCommand 클래스 생성
// ==> 클라이언트의 데이터를 읽고 출력하는 것을 담당할
//    Request와 Response클래스 생성
// ==> 기존 Command구현체는 Command인터페이스를 구현하는대신
//     AbstractCommand를 상속 받도록 변경
// ==> 또한 execute(BufferedReader, PrintWriter) 대신
//    execute(Request, Response) 를 오버라이딩 하도록 변경
// ==> 이유?
//     클라이언트와 데이터를 주고 받는 것을 조금 더 쉽게 하기위해 
// 
// 5단계 회원관리에 검색 기능을 추가한다 == 그래도 클라이언트는 변경할 필요가 없다
// ==> 어플리케이션 서버 아키텍쳐의 장점은 서버의 기능을 변경하더라도 클라리언트를 변경할 필요가 없다는 것
// ==> 즉, 다시 클라이언트를 배포할 필요없다 만약 서버인 네이버에 기능이 추가된다고해서 클라이언트인 
//     크롬 브라우져를 재설치하지 않아도 네이버의 새로운 기능을 사용할 수 있다  
// ==> 작업 
//    1) MemberDao에 키워드로 회원 정보를 찾는 findByKeyword()를 추가
//
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// 6단계: 사진 게시판 추가
// 작업
// 1) PhotoBoard 도메인 클래스 정의
// 2) PhotoBoardDao와 PhotoBoardDaoImpl 정의
//    - findAll() 메서드 추가
// 3) PhotoBoardListCommand 추가
// 4) ApplicationInitializer에 PhotoBoardListCommand를 등록한다.
// 5) PhotoBoardDao와 PhotoBoardDaoImpl 변경
//    - insert() 메서드 추가
// 6) PhotoBoardAddCommand 추가
// 7) ApplicationInitializer에 PhotoBoardAddCommand를 등록한다.
// 8) PhotoBoardDao와 PhotoBoardDaoImpl 변경
//    - findByNo() 메서드 추가
// 9) PhotoBoardDetailCommand 추가
// 10) ApplicationInitializer에 PhotoBoardDetailCommand를 등록한다.
// 11) PhotoBoardDao와 PhotoBoardDaoImpl 변경
//    - update(), delete() 메서드 추가
// 12) PhotoBoardUpdateCommand, PhotoBoardDeleteCommand 추가
// 13) ApplicationInitializer에 PhotoBoardUpdateCommand, PhotoBoardDeleteCommand를 등록한다.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// 7단계: 사진 게시판 첨부 파일 기능 추가
// 작업
// 1) PhotoFile 도메인 클래스 정의
// 2) 사진 게시물 출력할 때 첨부파일도 함께 출력하기
// 2.1 PhotoFileDao와 PhotoFileDaoImpl 정의
//    - findByPhotoBoardNo(int) 메서드 추가
// 2.2 PhotoBoardDetailCommand 변경
//    - PhotoFileDao 의존 객체 필드 추가
// 2.3 ApplicationInitializer에 PhotoFileDao를 등록한다.
// 3) 사진 게시물 입력할 때 첨부파일도 입력하기
// 3.1 PhotoFileDao와 PhotoFileDaoImpl 정의
//    - insert(PhotoFile) 메서드 추가
// 3.2 PhotoBoardAddCommand 변경
//    - 첨부파일 입력 추가
// 3.3 ApplicationInitializer 변경
//    - PhotoBoardAddCommand의 생성자에 PhotoFileDao 주입
// 4) 사진 게시물 변경할 때 첨부파일도 변경하기
// 4.1 PhotoFileDao와 PhotoFileDaoImpl 정의
//    - deleteByPhotoBoardNo(int) 메서드 추가
// 4.2 PhotoBoardUpdateCommand 변경
//    - 첨부파일 입력 추가
// 4.3 ApplicationInitializer 변경
//    - PhotoBoardUpdateCommand의 생성자에 PhotoFileDao 주입
// 5) 사진 게시물 삭제할 때 첨부파일도 변경하기
// 5.1 PhotoBoardDeleteCommand 변경
//    - 첨부파일 삭제 추가
// 5.2 ApplicationInitializer 변경
//    - PhotoBoardDeleteCommand의 생성자에 PhotoFileDao 주입
//
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// 8단계: 사진 게시물을 등록할 때 첨부파일 등록과 함께 묶어 처리하라. 즉 한 트랜잭션으로 만들라!
// 트랜잭션 
// - 여러 데이터 변경 작업을 한 작업으로 묶은 것.
// 작업
// 1) ApplicationInitializer 변경
//    - Connection 객체의 Auto Commit을 false로 설정한다. 
// 2) PhotoBoardAddCommand 변경
//    - insert를 마친 후 commit()을 호출하여 트랜잭션이 종료되었음을 서버에 알린다.
// 3) AbstractCommand 변경
//    - 데이터 변경(insert,update,delete) 작업 중에 오류가 발생했을 때 
//      원래의 마지막 커밋 상태로 되돌리도록,
//      즉 현재까지 작업한 결과를 취소하도록,
//      커넥션 객체에 대해 rollback()을 호출하라!
//    - 데이터 변경 작업 중에 예외가 발생했음에도 불구하고 rollback()을 호출하지 않는다면
//      예외 발생 전까지 수행했던 모든 데이터 변경 작업이 그대로 임시 DB에 남아있다.
//    - 만약 동일한 커넥션 객체를 사용한다면 그 임시 DB에 저장된 데이터까지 조회된다.
//    - 물론 커넥션을 끊으면 임시 DB에 존재하는 작업들이 모두 제거된다.
//    - 문제는 회사에서 사용하는 애플리케이션은 주로 서버 애플리케이션이고,
//      서버 애플리케이션은 메모리나 객체 관리를 효율적으로 하기 위해 
//      한 번 만든 커넥션 객체는 쓰고 버리지 않고// 계속 유지하여 공유한다는 것이다.
//      따라서 커넥션에서 작업했던 임시 DB에 보관된 데이터가 계속 select 할 때 포함되는 문제가 발생한다.
//    - 그래서 트랜잭션에 묶인 작업 중 하나가 실패했을 때 commit()을 호출하지 않는 것은 당연하고
//      명시적으로 rollback()을 호출하여 임시 DB에 보관된 쓰레기를 정리해 주는 것이 반드시 필요하다!!!
// 4) 모든 Command의 작업에 대해 commit을 적용
//    - 각각의 Command 클래스의 execute()에서 commit을 수행하지 말고,
//      수퍼 클래스인 AbstractCommand의 execute()에서 commit을 수행하라.
//    - 그러면 각각의 Command 클래스에서 commit 할 필요가 없다.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// 
// 9단계: 서버에서 클라이언트 요청을 순차적으로 처리할 때 문제점과 그 해결책 
// [서버에서 클라이언트 요청을 처리하는 방법]
// 1) Stateful 방식 
//    - 서버와 연결한 후 연결을 끊을 때까지 계속 통신하는 방식이다.
//    - 클라이언트가 연결을 끊지 않으면 서버 쪽에 계속 소켓이 유지되기 때문에 메모리를 일정 점유한다.
//    - 그래서 많은 클라이언트의 요청을 처리하지 못한다.
// 2) Stateless 방식
//    - 서버와 연결한 후 요청/응답을 한 번만 수행한다. 그리고 연결을 끊는다.
//    - 서버에서 응답을 완료하면 자동으로 연결을 끊기 때문에 서버 쪽에 소켓을 계속을 유지하지 않는다.
//      그래서 Stateful 방식에 비해 메모리 낭비가 덜 하다.
//    - 단 요청할 때마다 서버와 연결해야 하기 때문에 연결하는데 일정 시간이 소요된다.
//    - 그러나 보다 많은 클라이언트 요청을 처리할 수 있어 대부분의 서비스에서 이 방식을 많이 사용한다.
// 3) Stateless 방식 + 멀티스레드
//    - 특히 Stateless 방식에 멀티스레드를 적용하면 동시에 많은 클라이언트 요청을 처리할 수 있다.
//    - 대부분의 서비스들이 이 조합을 사용한다.
// 
// 9단계의 목표가 "stateless + 싱글 스레드" 방식을 "stateless + 멀티 스레드"로 바꾸는 것이다. 
// 작업:
// 1) 클라이언트 요청 처리를 전담할 스레드 클래스를 정의한다.
//    => RequestHandlerThread
// 2) ServerApp의 service()가 수행하던 클라이언트 요청 처리를 RequestHandlerThread로 옮긴다.
// 
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// 10단계: 멀티 스레드 상황에서 DB 커넥션을 공유할 때의 문제점과 그 해결책 I
// 
// [멀티 스레드에서 DB 커넥션 공유할 때의 문제점 확인하기]
// 1) 클라이언트1
//    - /photoboard/add 를 실행한다.
//    - 사진 제목은 "aaaa", 수업은 101로 입력한다.
//    - 사진 파일은 a.gif, b.gif를 입력한다.
//    - mysql 클라이언트 프로그램을 이용하여 commit이 수행되기 전 상태를 확인한다.
//    - 그리고 파일 입력을 잠시 멈춘다.
// 2) 클라이언트2
//    - /board/add 를 실행한다.
//    - mysql 클라이언트 프로그램을 이용하여 lms_board에 입력된 것을 확인한다.
//    - 또한 lms_photo와 lms_photo_file 테이블도 확인한다.
//    - "클라이언트1"이 insert한 데이터도 들어가 있다.
//    - 왜? 클라이언트1과 클라이언트2의 요청을 처리할 때 사용하는 DB 커넥션가 같기 때문이다.
// 3) 클라이언트1
//    - 파일명을 255가 넘어가게 입력한다.
//    - 예외가 발생하면 rollback() 할 것이다.
//    - 그러나 이미 이전에 insert 작업들은 클라이언트2가 commit 하면서 테이블에 저장되었기 때문에
//      rollback 할 수 없다.
//    - 이것이 멀티 스레드에서 DB 커넥션을 공유할 때의 문제점이다.
// 
// [해결책 I]
// => DAO가 작업할 때 매번 새 커넥션을 사용한다.
// => Connection 팩토리를 사용하여 커넥션 객체를 준비한다.
// 
// 작업:
// 1) DB 커넥션 팩토리 객체를 생성한다.
//    => com.eomcs.util.ConnectionFactory 클래스 생성
// 2) DAO 구현체 변경
//    => 작업을 수행할 때 마다 ConnectionFactory에서 새 Connection을 얻은 다음에 작업을 수행한다. 
//    => BoardDao, MemberDao, LessonDao, PhotoBoardDao, PhotoFileDao 구현체 변경
// 3) ApplicationInitializer 변경
//    => DB 커넥션은 DAO에서 ConnectionFactory를 통해 얻기 때문에
//       이 클래스에서는 더이상 DB 커넥션 객체를 관리하지 않는다.
//    => 또한 DAO 객체를 생성할 때 생성자게 파라미터 값으로 커넥션 객체를 넘겨주지 않는다.
// 4) AbstractCommand 변경
//    => execute() 호출이 완료되었을 때 commit() 또는 rollback()을 호출하지 않는다.
//       DAO가 사용하는 커넥션 객체를 모르기 때문에 사실상 commit(), rollback()을 호출할 수 없다.
// 
// [이 방식의 문제점]
// => DAO에서 메서드가 호출될 때 새 커넥션을 사용하게 되면 
//    트랜잭션 관리가 불가능하다.
// 
// 다음 절차에 따라 확인해 보라!
// 실습:
// 1) /board/add 실행한다.
// 2) /board/list를 실행하여 입력된 결과를 확인한다.
// 3) /photoboard/add 실행한다.
// 4) /photoboard/list 실행하여 입력된 결과를 확인한다.
// 5) /photoboard/add 실행한다.
//    => 이때 첨부파일 두 개를 입력한 후, 세 번째 입력할 때 예외가 발생하도록 
//      긴 이름의 파일명을 입력한다.
//    => 예외가 발생했다는 메시지를 받을 것이다.
// 6) /photoboard/list 실행한다.
//    => 예외가 발생하기 전까지 입력했던 데이터가 그대로 DB에 보관된 것을 확인할 수 있다.
//    => 즉 트랜잭션을 다룰수 없었기 때문이다.
// 
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// 11단계: 멀티 스레드 상황에서 DB 커넥션을 공유할 때의 문제점과 그 해결책 II
// => 같은 스레드를 통해 DAO 작업을 수행할 때 같은 커넥션 객체 사용하기.
// => 어떻게?
//    "스레드 로컬(thread local) 변수"를 이용하여 커넥션 객체를 스레드에 보관한다.
//    DAO가 작업을 할 때 스레드에 보관된 커넥션 객체를 이용한다.
// 
// 작업:
// 1) ConnectionFactory 변경
//    => create()를 호출할 때 먼저 스레드에 저장된 것이 있는지 검사한 후 
//       있으면 그 커넥션 객체를 리턴하고,
//       없으면 새 커넥션을 만들어 리턴한다.
//    => commit()/rollback()을 사용하려면 커넥션의 auto commit을 false로 설정해야 한다.
// 2) AbstractCommand 변경 
//    => execute()에 commit()과 rollback()을 적용한다.
// 3) Command 구현체 변경
//    => Command에서 커넥션 객체를 사용한 후 닫지 않도록 한다.
// 
///////////////////////////////////////////////////////////////////////////////////////////////////
// 
// 12단계: 커넥션풀(Flyweight 디자인 패턴 응용)을 이용하여 커넥션 객체를 재활용하기
// => 클라이언트 요청을 처리할 때마다 매번 DB 커넥션을 생성한다면 
//    DB 커넥션 생성에 비용(실행시간, 메모리)이 많이 든다.
// => 해결책?
//    DB 커넥션을 생성한 다음에 버리지 말고 보관했다가 다시 사용하는 것이다.
// 
// 작업:
// 1) ConnectionFactory 클래스의 이름을 DataSource로 변경한다.
//    - 생성된 커넥션들을 관리하도록 코드를 변경한다.
//    - 커넥션을 반납하는 returnConnection() 메서드를 추가한다.
// 2) DAO 구현체를 변경한다.
//    - DataSource 객체를 의존 객체로 지정한다.
//    - 생성자에서 DataSource 객체를 받는다.
//    - 각 메서드는 DataSource 객체를 통해 커넥션을 받는다.
// 3) ApplicationInitializer 변경
//    - DataSource 객체 생성
//    - DAO에 DataSource 객체 주입
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// 
// 13단계: Mybatis 퍼시스턴스 프레임워크 적용하기
// => 자바 소스 코드에서 SQL을 분리하여 별도의 파일에서 관리한다.
// => JDBC 코드를 캡슐화하여 DB 프로그래밍을 간결하게 한다.
// 
// 작업:
// 1) Mybatis 설정 파일 준비
//    - src/main/resources/com/eomcs/lms/conf/mybatis-config.xml 생성
//    - src/main/resources/com/eomcs/lms/conf/jdbc.properties 생성
// 2) LessonDao에 Mybatis 적용
//    - src/main/resources/com/eomcs/lms/mapper/LessonMapper.xml 생성
//    - LessonDaoImpl 클래스 변경
//    - ApplicationInitializer 클래스 변경
// 3) MemberDao에 Mybatis 적용
//    - src/main/resources/com/eomcs/lms/mapper/MemberMapper.xml 생성
//    - MemberDaoImpl 클래스 변경
//    - ApplicationInitializer 클래스 변경
// 4) BoardDao에 Mybatis 적용
//    - src/main/resources/com/eomcs/lms/mapper/BoardMapper.xml 생성
//    - BoardDaoImpl 클래스 변경
//    - ApplicationInitializer 클래스 변경 
// 5) PhotoBoardDao에 Mybatis 적용
//    - src/main/resources/com/eomcs/lms/mapper/PhotoBoardMapper.xml 생성
//    - PhotoBoardDaoImpl 클래스 변경
//    - ApplicationInitializer 클래스 변경
// 6) PhotoFileDao에 Mybatis 적용
//    - src/main/resources/com/eomcs/lms/mapper/PhotoFileMapper.xml 생성
//    - PhotoFileDaoImpl 클래스 변경
//    - ApplicationInitializer 클래스 변경
// 
///////////////////////////////////////////////////////////////////////////////////////////////////
// 
// 14단계: Mybatis 퍼시스턴스 프레임워크에 트랜잭션 관리자 도입하기
// => 트랜잭션 관리자를 도입하여 여러 개의 데이터 변경 작업을 한 단위의 작업으로 묶어 다룬다.
// 
// 작업:
// 1) SqlSessionFactoryProxy 생성
//    => Mybatis가 제공하는 SqlSessionFactory 객체를 대행한다.
//    => 트랜잭션을 위한 SqlSession 객체를 준비하고 해제하는 일을 한다.
//    => 트랜잭션을 시작하면 스레드 보관소에 SqlSession 객체를 보관한다.
//       그래서 스레드가 수행하는 모든 데이터 변경 작업을 한 SqlSession 객체가 다루게 한다.
// 2) SqlSessionProxy 생성
//    => Mybatis가 제공하는 SqlSession 객체를 대행한다.
//    => 트랜잭션 중에는 close()를 하지 않는다.
// 3) TransactionManager 생성 
//    => 트랜잭션을 시작시키고 완료시키는 일을 한다.
//    => SqlSession 객체를 통해 데이터 변경 작업들을 commit()하고 rollback()하는 일을 한다.
// 4) DAO 변경 
//    => DAO에서 데이터 변경(insert/update/delete) 후에 commit() 하지 말라!
//    => 트랜잭션을 사용할 때는 DAO에서 commit() 하는 것이 아니다.
//       왜? 여러 DAO의 작업을 한 단위로 묶어서 commit() 해야 하기 때문이다.
//    => 트랜잭션을 사용하지 않을 때는 auto commit 이 true인 SqlSession을 사용하기 때문에
//       아무런 문제가 없다.
// 5) Command 변경 
//    => 트랜잭션을 사용해야 하는 Command에 대해서는 TransactionManager를 주입하라!
//       예) PhotoBoardAddCommand, PhotoBoardDeleteCommand, PhotoBoardUpdateCommand,
//          LessonDeleteCommand 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 