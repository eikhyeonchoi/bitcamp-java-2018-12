// 2단계: 클라이언트의 연결을 승인한다.

// 3단계: 클라이언트와 서버 간에 간단한 문자열 데이터를 주고 받는다.

// 4단계: 클라이언트와 서버 간에 인스턴스를 주고 받는다.

// 5단계: 클라이언트가 보낸 add, list, quit 명령을 받아 처리한다.

// 6단계: 클라이언트가 보낸 회원 관리 명령어(/member/*)를 처리한다.

// 7단계: 클라이언트의 연결을 승인한다.
// 7단계: 클라이언트에서 요청한 /board/* 명령을 처리한다.
// 7단계: 클라이언트에서 요청한 /member/* 명령을 처리한다.
// 7단계: 클라이언트에서 요청한 /lesson/* 명령을 처리한다.

// 8단계: 클라이언트 요청을 처리하는 클래스에 대해 리팩토링 수행
// static vs instance, 생성자, 접근제한자
// 클라이언트의 요청을 처리하는 클래스라는 의미로 
// 클래스명을 *Service로 변경한다.

// 9단계: 클라이언트 요청을 처리하는 서비스 클래스를 별도의 패키지로 분류하기

// 10단계: 데이터를 파일로 관리한다.

// ======================================================================
// 따로 클라이언트 만들기
// ======================================================================

// 11단계 부터 클라이언트를 다른 프로젝트에서 실행할 것
// 11단계: 서비스 클래스의 일반화(상속)를 수행한다.
// 11단계: AbstractService 상속 받기

// 12단계: Service 클래스에서 데이터 처리 코드를 별도의 클래스(DAO)로 분리

// 13단계 statful -> stateless

// 14단계 proxy pattern 적용

// 15단계 여러 클라이언트 요청을 처리할 때의 문제점과 해결책 - 멀티쓰레드 
// 15단계 -2  스레드풀 적용하기

// ======================================================================
// 기존 서버 버리고 MariaDB사용
// ======================================================================

// 16단계 java-project-server 버리고 MariaDB 사용하기 JDBC 시작
// 16단계 DAO에 JDBC적용하기
// 현재 프로젝트에 mariadb JDBC 드라이버를 추가 
// 수업(Lesson), 회원(Member), 게시물(Board) 정보를 저장할 테이블을 생성한다
// LessonDaoImpl, MemberDaoImpl, BoardDaoImpl 클래스에 JDBC 적용한다

// 17단계 Connection 객체 공유하기
// 가비지 안만들고 매번 auth과정 없애면 시간절약되니까 Connection공유

// 18단계 기존 코드에 옵저버 패턴 적용하기
// 옵저버 패턴을 적용해 어플리케이션이 시작할 때 사용할 객체를 준비
// 1) 어플리케이션이 시작되면 옵저버한테알린다
// 2) 옵저버는 어플리케이션이 사용할 객체를 만들어 보관소에 저장한다
// 3) 어플리케이션이 사용자를 명령어를 처리할 때 보관소에서 해당 객체를 꺼내 사용
// coding 과정 
// 1) 옵저버에게 상태 변경을 알릴 때 호출할 규칙을 (인터페이스) 정의 - ApplicationContextListener interface
// 2) 규칙에 따라 옵저버를 만든다 - ApplicationInitializer
// 3) 옵저버를 App클래스에 등록 - App.addApplicationContextListener()
// 4) App 클래스의 서비스를 시작 또는 종료할 때 등록된 옵저버에게 알린다 (옵저버의 메서드를 호출한다)
//        ==> service() 메서드의 시작과 종료 부분에 옵저버 메서드 호출
// 






















